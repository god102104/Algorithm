---
layout: post
title: 392. Is Subsequence
category: leetcode
date: 2025-02-19 16:06:00 +0900
description: https://leetcode.com/problems/is-subsequence/description/?envType=study-plan-v2&envId=top-interview-150
img: leetcode.png # Add image post (optional)
fig-caption: # Add figcaption (optional)
status: success
---

# 392. Is Subsequence

Given two strings s and t, return true if s is a subsequence of t, or false otherwise.

A subsequence of a string is a new string that is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (i.e., "ace" is a subsequence of "abcde" while "aec" is not).

 

> **Example 1**
> 
> Input: s = "abc", t = "ahbgdc"
> 
> Output: true


> **Example 2**
> 
> Input: s = "axc", t = "ahbgdc"
> 
> Output: false


### Solution (Two pointer)

```cpp
class Solution {
public:
    bool isSubsequence(string s, string t) {
        if (s.empty()) return true;  
        if (t.empty()) return false; 
        int idx1 = 0; 
        int tLength = t.size();

        for (int idx2 = 0; idx2 < tLength; ++idx2) {
            if (s[idx1] == t[idx2]) {
                idx1++; 
                if (idx1 == s.size()) return true;
            }
        }
        return false;
    }
};
```

DP를 이용한 풀이도 있다.

### Solution (DP)

```cpp
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int m = s.size(); // s의 길이
        int n = t.size(); // t의 길이

        // DP 테이블 초기화 (~1차원으로 축소)
        vector<bool> dp(n + 1, true);

        // DP 테이블 갱신
        for (int i = 1; i <= m; ++i) {
            bool prev = dp[0]; // 이전 상태 저장
            dp[0] = false;     // s의 특정 문자부터 매칭 시작
            for (int j = 1; j <= n; ++j) {
                bool temp = dp[j];
                if (s[i - 1] == t[j - 1]) { 
                    dp[j] = prev; // 매칭 성공 시 이전 값 사용
                } else {
                    dp[j] = dp[j - 1]; // 매칭 실패, 이전 t만 사용
                }
                prev = temp;
            }
        }

        return dp[n]; // s 전체가 t에서 매칭되었는지 확인
    }
};
```