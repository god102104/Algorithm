---
layout: post
title: 33. Search in Rotated Sorted Array
category: leetcode
date: 2025-03-22 20:16:00 +0900
description: https://leetcode.com/problems/search-in-rotated-sorted-array/description/?envType=study-plan-v2&envId=top-interview-150
img: leetcode.png # Add image post (optional)
fig-caption: # Add figcaption (optional)
status: success
difficulty: Medium
---

# 33. Search in Rotated Sorted Array

There is an integer array nums sorted in ascending order (with distinct values).

Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].

Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.

You must write an algorithm with O(log n) runtime complexity.

 

> **Example 1**
> 
> Input: nums = [4,5,6,7,0,1,2], target = 0
> 
> Output: 4


> **Example 2**
> 
> Input: nums = [4,5,6,7,0,1,2], target = 3
> 
> Output: -1


> **Example 3**
> 
> Input: nums = [1], target = 0
> 
> Output: -1


### Solution 
```cpp
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int left = 0, right = nums.size() - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2; // 중간 지점 계산

            if (nums[mid] == target) 
                return mid; // 값을 찾음

            // 왼쪽 절반이 정렬된 경우
            if (nums[left] <= nums[mid]) {
                if (nums[left] <= target && target < nums[mid]) {
                    right = mid - 1; // 정렬된 왼쪽에서 찾기
                } else {
                    left = mid + 1; // 오른쪽으로 검색 이동
                }
            }
            // 오른쪽 절반이 정렬된 경우
            else {
                if (nums[mid] < target && target <= nums[right]) {
                    left = mid + 1; // 정렬된 오른쪽에서 찾기
                } else {
                    right = mid - 1; // 왼쪽으로 검색 이동
                }
            }
        }

        return -1; // 값을 찾지 못한 경우
    }
};
```